from pydantic import BaseModel, Field, validator
from typing import List, Optional, Dict, Any, Tuple
from datetime import datetime
import re

# List of currently included MongoDB collections
# 1. emails: contains all emails that have been processed by the system
# 2. cargos: contains all cargos that have been extracted from the emails
# 3. ships: contains all ships that have been extracted from the emails
# 4. extractions: contains all emails and their extracted entities, to be used for training and fine-tuning the model
# 5. failed_entries: contains all emails and their extracted objects, that failed validation and were not added to the primary collections

def extract_number(input_str: str) -> Optional[int]:
    # Preprocess 1: If there is a range - take the right hand side: i.e (10k - 35k) -> 35k
    input_str = input_str.split("-")[-1]
    
    # Preprocess 2: Remove decimal parts when exactly two digits follow the period or comma
    input_str = re.sub(r'[\.,]\d{2}\b', '', input_str)
    
    # Find all sequences of digits, possibly separated by commas
    matches = re.findall(r'(\d{1,3}(?:,\d{3})*)', input_str)
    
    # Join matches and remove commas to form a single number string
    num_str = ''.join(matches).replace(',', '')

    # Convert to integer if not empty, otherwise return None or an empty string
    value = int(num_str) if num_str else None

    if value:
        # Handle case where small number is found (e.g., 0.5, 0.75, etc.) and must be multiplied by 1000 (k or K = 1000)
        if value < 1000:
            value = value * 1000

    return value

def extract_weights(s: str) -> Tuple[int, int] | Tuple[None, None]:

    # Convert commas used as decimal points to periods
    text = re.sub(r'(?<=\d),(?=\d)', '.', s)

    # Define a regular expression pattern to find both integer and decimal values
    # Exclude matches directly followed by "%" 
    pattern = r'\b(\d+(?:\.\d+)?)(?!\s*[%|pct])(?=\D|$)'

    # Find all matches in the text
    matches = re.findall(pattern, text)

    # Extract the number values as floats
    if not matches:
        return None, None

    matches = [float(match) for match in matches]

    # Handle case where small number is found (e.g., 0.5, 0.75, etc.) and must be multiplied by 1000 (k or K = 1000)
    if len(matches) > 0:
        if matches[0] < 1000:
            matches[0] = matches[0] * 1000

    if len(matches) > 1:
        if matches[1] < 1000:
            matches[1] = matches[1] * 1000

    if len(matches) == 1:  # Return the same value for both upper and lower bounds if only one number is found
        return int(matches[0]), int(matches[0])

    if len(matches) > 1:  # Return the minimum on the left and the maximum on the right
        return min(int(matches[0]), int(matches[1])), max(int(matches[0]), int(matches[1]))
    
    return None, None

months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
statuses = ["open", "prompt", "opn", "op", "pmt"]

def extract_month(s: str) -> Optional[int]:
    for i, month in enumerate(months, start=1):
        if month.lower() in s.lower():
            return i

    return None

class LocationForGeocoding(BaseModel):
    port: str = "" # Name of the port
    sea: str = "" # Name of the sea
    ocean: str = "" # Name of the ocean

    def clean(self):
        """Cleans up location object by 1. remove any leading/trailing spaces, 2. convert to lowercase. 3. remove punctuation."""
        self.port = re.sub(r'[^\w\s]', '', self.port.strip().lower())
        self.sea = re.sub(r'[^\w\s]', '', self.sea.strip().lower())
        self.ocean = re.sub(r'[^\w\s]', '', self.ocean.strip().lower())

class GeoJsonLocation(BaseModel):
    """Location object in GeoJSON format."""
    type: str = "Point"
    coordinates: List[float] = []

class GeocodedLocation(BaseModel):
    """Location object typically obtained and filled from geocoding a location string."""
    name: str
    location: GeoJsonLocation

    address: Optional[str]
    raw: Optional[Dict[str, Any]]

class MongoEmail(BaseModel):
    m_id: Optional[Any] = Field(alias="_id", default=None) # ID of the email generated by MongoDB
    id: Optional[str] # ID of the email(from Message-ID header)
    subject: Optional[str] # Subject of the email
    sender: Optional[str] # Email address of the sender
    recipients: Optional[str] # List of email addresses of the recipients
    date_received: Optional[str] # Timestamp of when the email was received
    body: Optional[str] # Content of the email

    timestamp_added_to_db: Optional[datetime] = None # Timestamp of when the email read from the inbox and ADDED to the database.

    timestamp_entities_extracted: Optional[datetime] = None # Timestamp of when the entities were extracted from the email

def update_ship_entry_with_calculated_fields(existing_values: Dict):
    """Modifies existing ship object in place, adding calculated fields and embeddings."""
    capacity = extract_number(existing_values.get("capacity", ""))

    # Further update month in case ship has a status of "open" or "prompt" to be the month of the timestamp of the email.
    if existing_values.get("status", "").lower() in statuses:
        # Convert string to datetime object
        date_object = datetime.fromisoformat(existing_values["email"]["date_received"])

        # Get the month as a string
        month_string = date_object.strftime("%B")
        existing_values["month"] = month_string[:3]
    
    # Case if month is not given - TODO: (maybe set to current month?)
    if not existing_values.get("month", ""):
        ...
        # existing_values["month"] = datetime.now().strftime("%b")
    
    # Clean location up

    location = LocationForGeocoding(**existing_values.get("location", {}))
    location.clean()
    existing_values["location"] = location.model_dump()

    # If capacity is not specified, pass an empty string to extract_number, which will return None
    existing_values["capacity_int"] = capacity
    existing_values["month_int"] = extract_month(existing_values.get("month", ""))

class MongoShip(BaseModel):
    # Fields to extract from email
    id: Optional[Any] = Field(alias="_id", default=None) # ID of the ship generated by MongoDB

    name: Optional[str] # Name of the ship
    status: Optional[str] # Status of the ship (e.g., open, on subs, fixed, spot, etc.)
    month: Optional[str] # Month when the ship is available for cargoes
    capacity: Optional[str] # Capacity of the ship

    location: LocationForGeocoding = LocationForGeocoding() # Current location of the ship

    # Fields to fill on creation
    email: MongoEmail # Email object
    timestamp_created: datetime = Field(default_factory=datetime.now) # Timestamp of when the ship was created

    # Fields to calculate on creation (to be used for simple queries)
    capacity_int: Optional[int] # Capacity of the ship in integer form
    month_int: Optional[int] # Month when the ship is available for cargoes in integer form
    location_geocoded: Optional[GeocodedLocation] = None # Geocoded location of the ship

    # Extra fields
    pairs_with: Optional[List[Any]] = Field(default_factory=list) # List of cargo IDs that this ship is paired with
    timestamp_pairs_updated: Optional[datetime] = None # Timestamp of when the pairs_with field was last updated

    class Config:
        extra = 'allow'

def update_cargo_entry_with_calculated_fields(existing_values: Dict):
    """Modifies existing cargo object in place, adding calculated fields and vector embeddings."""

    min_max_weights = extract_weights(existing_values.get("capacity", ""))

    # Update capacity to be the minimum and maximum weights
    existing_values["capacity_min_int"], existing_values["capacity_max_int"] = min_max_weights

    # If capacity is not specified, pass an empty string to extract_number, which will return None
    existing_values["month_int"] = extract_month(existing_values.get("month", ""))

    # handle commission calculation
    comission = 20.0 # set to high number default
    match = re.search(r'\b(\d+(?:[.,]\d+)?)\b', existing_values.get("commission", ""))
    if match:
        match = match.group(0).replace(",", ".") # handle comma as decimal separator too
        comission = float(match)

    existing_values["commission_float"] = comission

    # clean up locations
    location_from = LocationForGeocoding(**existing_values.get("location_from", {}))
    location_from.clean()
    existing_values["location_from"] = location_from.model_dump()

    location_to = LocationForGeocoding(**existing_values.get("location_to", {}))
    location_to.clean()
    existing_values["location_to"] = location_to.model_dump()

class MongoCargo(BaseModel):
    id: Optional[Any] = Field(alias="_id", default=None) # ID of the cargo generated by MongoDB

    # Fields to extract from email
    name: Optional[str] # Name of the cargo
    capacity: Optional[str] # Capacity or weight of the cargo
    
    location_from: LocationForGeocoding = LocationForGeocoding() # Location where cargo is to be picked up
    location_to: LocationForGeocoding = LocationForGeocoding() # Location where cargo is to be delivered

    month: Optional[str] # Month of shipment
    commission: Optional[str] # Commission percentage (e.g., 2.5%)

    # Fields to fill on creation
    email: MongoEmail # Email object
    timestamp_created: datetime = Field(default_factory=datetime.now) # Timestamp of when the cargo was created

    # Fields to calculate on creation (to be used for simple queries)
    capacity_min_int: Optional[int] # Capacity of the cargo lower bound in integer form
    capacity_max_int: Optional[int] # Capacity of the cargo upper bound in integer form

    month_int: Optional[int] # Month when the ship is available for cargoes in integer form
    commission_float: Optional[float] # Commission percentage in float form

    location_from_geocoded: Optional[GeocodedLocation] = None # Geocoded location of the cargo pickup
    location_to_geocoded: Optional[GeocodedLocation] = None # Geocoded location of the cargo delivery

    # Extra fields
    pairs_with: Optional[List[Any]] = Field(default_factory=list) # List of ship IDs that this cargo is paired with

    class Config:
        extra = 'allow'

class FailedEntry(BaseModel):
    id: Optional[Any] = Field(alias="_id", default=None) # ID of the object generated by MongoDB
    email: MongoEmail
    timestamp_created: datetime = Field(default_factory=datetime.now) # Timestamp of when the object was created

    reason: Optional[str] # Reason why the object failed to be processed

    class Config:
        extra = 'allow'

class MongoEmailAndExtractedEntities(BaseModel):
    email: MongoEmail
    entities: List[MongoCargo | MongoShip] = Field(default_factory=list) # List of entities extracted from the email
    failed_entries: List[FailedEntry] = Field(default_factory=list) # List of failed entries

    audited: bool = False # Whether the email has been audited by a human, and new entities have been added for training purposes
    timestamp_audited: Optional[datetime] = None # Timestamp of when the email was audited
    audited_entities: Optional[List] = None # List of entities to represent the email, after auditing

# Setup 1
#1. Go over all ships with no cargo pairs, i.e find all ships with ship_id not in any CargoShipPair.ship_id
#2. For each ship, find all cargoes that match the ship's criteria
#3. Score each pair of ship and cargo
#4. Sort all pairs by score

# Setup 2
#1. for Ship object, store a list of matched_cargo_ids
#2. for Cargo object, store a list of matched_ship_ids

# so, we will go over all ship objects, and find all cargoes that match the ship's criteria-